{
  "meta": {
    "description": "Abstract strategies for generating pedagogical distractors, linked to syllabus topics."
  },
  "traps": [
    {
      "concept": "loop_scoping",
      "related_concept_ids": ["loops", "environment_model"],
      "trigger": "empty_block_optimization",
      "strategy": {
        "instruction": "Design a loop (while/for) that modifies a variable but contains no `let` or `const` declarations inside its body block.",
        "question_intent": "Test if the student incorrectly assumes a new environment frame is created for every iteration.",
        "correct_logic": "No frame is created because the block is scan-empty.",
        "distractor_logic": "One frame is created per iteration."
      }
    },
    {
      "concept": "list_notation",
      "related_concept_ids": ["lists", "pairs", "list_library"],
      "trigger": "box_vs_list_output",
      "strategy": {
        "instruction": "Construct a nested pair structure that does not form a proper list (e.g., ends in a number, or pairs nested in pairs).",
        "question_intent": "Test if the student knows the specific output format of `display` (Box Notation) vs `display_list`.",
        "correct_logic": "Output uses array bracket notation `[1, [2, ...]]` strictly following the pair structure.",
        "distractor_logic": "Output uses `list(...)` notation or flattens the structure."
      }
    },
    {
      "concept": "lazy_evaluation",
      "related_concept_ids": ["streams", "substitution_model"],
      "trigger": "logical_operator_short_circuit",
      "strategy": {
        "instruction": "Create a logical expression (&& or ||) where the second operand would cause a runtime error (e.g., division by zero, undefined variable, infinite loop).",
        "question_intent": "Test if the student understands that the second operand is ignored if the result is determined by the first.",
        "correct_logic": "The error is never evaluated.",
        "distractor_logic": "The program crashes or hangs."
      }
    },
    {
      "concept": "recursion_process",
      "related_concept_ids": ["recursion_process", "accumulate", "list_library"],
      "trigger": "deferred_operation_buildup",
      "strategy": {
        "instruction": "Write a recursive function that looks similar to an iterative one but has a pending operation (e.g., multiplication, addition) after the recursive call returns.",
        "question_intent": "Test the distinction between Recursive Function (syntax) and Recursive Process (runtime behavior).",
        "correct_logic": "It is a Recursive Process because of deferred operations.",
        "distractor_logic": "It is an Iterative Process because it calls itself."
      }
    },
    {
      "concept": "scanning_phase",
      "related_concept_ids": ["environment_model", "basics"],
      "trigger": "temporal_dead_zone",
      "strategy": {
        "instruction": "Place a variable access lexically *before* its declaration within the same scope block.",
        "question_intent": "Test understanding of the 'Scanning' phase (hoisting behavior in Source).",
        "correct_logic": "Error: Name declared but not yet assigned (Source scans first).",
        "distractor_logic": "Returns `undefined` (Old JS behavior) or accesses a variable from an outer scope."
      }
    },
    {
      "concept": "stream_tail",
      "related_concept_ids": ["streams", "stream_map"],
      "trigger": "delayed_evaluation",
      "strategy": {
        "instruction": "Embed a side effect (e.g., `display`, `error`) or a computationally expensive operation inside the tail argument of a stream constructor.",
        "question_intent": "Test if the student knows the tail is a thunk and not evaluated at construction time.",
        "correct_logic": "The effect/error does not happen immediately.",
        "distractor_logic": "The effect/error happens during definition."
      }
    },
    {
      "concept": "append",
      "related_concept_ids": ["list_library", "state"],
      "trigger": "structural_sharing",
      "strategy": {
        "instruction": "Use `append` to join two lists, then mutate the *second* original list (e.g., `set_head`). Ask about the `append` result.",
        "question_intent": "Test understanding that `append` copies the first list but shares the pointer to the second.",
        "correct_logic": "The result changes because it points to the mutated second list.",
        "distractor_logic": "The result is unchanged because `append` is assumed to copy everything."
      }
    }
  ]
}